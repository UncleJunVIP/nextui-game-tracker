// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
)

const fetchIDByPath = `-- name: FetchIDByPath :one
SELECT id
FROM games
WHERE path = ?
`

func (q *Queries) FetchIDByPath(ctx context.Context, path sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, fetchIDByPath, path)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findLastSession = `-- name: FindLastSession :one
SELECT id, game_id, start_time, end_time, force_stopped, invalid, deleted
FROM main.play_sessions
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) FindLastSession(ctx context.Context) (PlaySession, error) {
	row := q.db.QueryRowContext(ctx, findLastSession)
	var i PlaySession
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.StartTime,
		&i.EndTime,
		&i.ForceStopped,
		&i.Invalid,
		&i.Deleted,
	)
	return i, err
}

const listGames = `-- name: ListGames :many
SELECT id, name, path, updated_at
FROM games
ORDER BY name
`

func (q *Queries) ListGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, listGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newGame = `-- name: NewGame :one
INSERT INTO games (name, path, updated_at)
VALUES (?, ?, ?)
RETURNING id
`

type NewGameParams struct {
	Name      sql.NullString
	Path      sql.NullString
	UpdatedAt sql.NullString
}

func (q *Queries) NewGame(ctx context.Context, arg NewGameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, newGame, arg.Name, arg.Path, arg.UpdatedAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const startSession = `-- name: StartSession :exec
INSERT INTO play_sessions (game_id, start_time)
VALUES (?, ?)
`

type StartSessionParams struct {
	GameID    sql.NullInt64
	StartTime sql.NullString
}

func (q *Queries) StartSession(ctx context.Context, arg StartSessionParams) error {
	_, err := q.db.ExecContext(ctx, startSession, arg.GameID, arg.StartTime)
	return err
}

const stopSession = `-- name: StopSession :many
UPDATE play_sessions
SET end_time      = ?1,
    force_stopped = ?2,
    invalid       = CASE
                        WHEN ?1 < start_time THEN 1
                        ELSE 0
        END
WHERE end_time IS NULL
RETURNING id, game_id, start_time, end_time, force_stopped, invalid, deleted
`

type StopSessionParams struct {
	EndTime      sql.NullString
	ForceStopped sql.NullInt64
}

func (q *Queries) StopSession(ctx context.Context, arg StopSessionParams) ([]PlaySession, error) {
	rows, err := q.db.QueryContext(ctx, stopSession, arg.EndTime, arg.ForceStopped)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlaySession
	for rows.Next() {
		var i PlaySession
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.StartTime,
			&i.EndTime,
			&i.ForceStopped,
			&i.Invalid,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
